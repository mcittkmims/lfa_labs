# Chomsky Normal Form

### Course: Formal Languages & Finite Automata
### Author: Adrian Vremere

----

## Theory

### Chomsky Normal Form (CNF)

Chomsky Normal Form is a simplified form for context-free grammars, named after Noam Chomsky, the renowned linguist who made significant contributions to formal language theory. A context-free grammar is in Chomsky Normal Form if all of its production rules are in one of the following forms:

1. A → BC (where A, B, and C are non-terminal symbols)
2. A → a (where A is a non-terminal symbol and a is a terminal symbol)
3. S → ε (where S is the start symbol and ε is the empty string)

The third rule is only allowed if the empty string is in the language generated by the grammar, and only for the start symbol.

### Properties and Significance

Chomsky Normal Form is important in theoretical computer science and computational linguistics for several reasons:

1. **Simplicity**: The restricted form of productions makes grammars easier to analyze and understand.

2. **Parsing Algorithms**: Many parsing algorithms, such as the Cocke-Younger-Kasami (CYK) algorithm, require grammars to be in CNF to operate efficiently.

3. **Theoretical Proofs**: Many theoretical results about context-free grammars are easier to prove when the grammars are in CNF.

4. **Elimination of Complexity**: CNF eliminates potentially problematic grammar features like unit productions and ε-productions.

### Transformation to CNF

Any context-free grammar can be transformed into an equivalent grammar in Chomsky Normal Form. The transformation process typically involves several steps:

1. **Eliminating ε-Productions**: Remove all productions of the form A → ε (except possibly for the start symbol) and modify other productions to account for this change.

2. **Eliminating Renaming (Unit Productions)**: Remove all productions of the form A → B where B is a non-terminal (also called unit productions).

3. **Eliminating Inaccessible Symbols**: Remove all symbols that cannot be reached from the start symbol.

4. **Eliminating Non-Productive Symbols**: Remove all symbols that cannot derive any terminal string.

5. **Converting Remaining Productions to CNF Form**:
    - For productions A → B1B2...Bn where n > 2, introduce new non-terminals to break them into binary productions.
    - For productions A → aB or A → Ba where a is a terminal and B is a non-terminal, replace the terminal with a new non-terminal X and add the production X → a.

Each step preserves the language generated by the grammar, ensuring that the final CNF grammar generates the same language as the original grammar.

### Formal Transformation Algorithm

More formally, the algorithm to convert a context-free grammar G to Chomsky Normal Form involves:

1. **DEL**: Eliminate all ε-productions (except possibly S₀ → ε if the empty string is in the language).

2. **UNIT**: Eliminate all unit productions (renaming) A → B where B is a non-terminal.

3. **ACCESS**: Remove all inaccessible symbols - those that cannot be reached from the start symbol.

4. **PROD**: Remove all non-productive symbols - those that cannot derive any terminal string.

5. **TERM**: Replace each production of the form A → α₁aα₂ (where a is a terminal and α₁,α₂ are strings of grammar symbols) with A → α₁Xₐα₂ and add Xₐ → a, where Xₐ is a new non-terminal unique to terminal a.

6. **BIN**: Replace each production of the form A → X₁X₂...Xₙ (where n > 2 and each Xᵢ is a non-terminal) with A → X₁Y₁, Y₁ → X₂Y₂, ..., Yₙ₋₂ → Xₙ₋₁Xₙ, where each Yᵢ is a new non-terminal.

### Limitations and Considerations

While any context-free grammar can be converted to CNF, it's important to note:

1. The transformation can significantly increase the number of non-terminals and productions.

2. The transformed grammar, while generating the same language, may lose some of the structural properties of the original grammar that were linguistically meaningful.

3. For practical applications, such as natural language parsing, pure CNF might not always be the most efficient representation, and various modifications or relaxations of CNF are often used.

### Applications in Parsing

The primary application of Chomsky Normal Form is in parsing algorithms. The CYK (Cocke-Younger-Kasami) algorithm, a dynamic programming algorithm for parsing context-free languages, requires the grammar to be in CNF. With a grammar in CNF, the CYK algorithm can determine whether a string belongs to the language in O(n³) time, where n is the length of the input string.

The CYK algorithm's efficiency stems from the fact that all productions in CNF have at most two non-terminals on the right-hand side, which allows for a straightforward dynamic programming approach to building parse trees.

### Theoretical Implications

Chomsky Normal Form plays a crucial role in various theoretical results about context-free languages:

1. It provides a standardized form for proving closure properties of context-free languages.

2. It helps establish the relationship between context-free languages and other formal language classes in the Chomsky hierarchy.

3. It facilitates proofs of the pumping lemma for context-free languages, a key tool for proving that certain languages are not context-free.

In summary, Chomsky Normal Form represents a fundamental concept in formal language theory that simplifies the analysis of context-free grammars while preserving their generative power.


## Objectives:
1. Learn about Chomsky Normal Form (CNF) [1].
2. Get familiar with the approaches of normalizing a grammar.
3. Implement a method for normalizing an input grammar by the rules of CNF.
    1. The implementation needs to be encapsulated in a method with an appropriate signature (also ideally in an appropriate class/type).
    2. The implemented functionality needs executed and tested.
    3. Also, another **BONUS point** would be given if the student will make the aforementioned function to accept any grammar, not only the one from the student's variant.


## Implementation Description

The implementation consists of a `Grammar` class that provides functionality for working with formal grammars in language theory. The class offers methods to manipulate and transform grammars, particularly focusing on normalization techniques required for Chomsky Normal Form.

### Core Data Structure

The grammar is represented by four main components:

```java
private Set<String> nonTerminals;
private Set<String> terminals;
private Map<String, Set<String>> productionRules;
private String startSymbol;
```

The `nonTerminals` set contains all non-terminal symbols in the grammar, which are typically represented by uppercase letters (such as A, B, S). The `terminals` set contains all terminal symbols, which are the actual characters of the language (like a, b). The `productionRules` map represents the production rules where keys are non-terminal symbols and values are sets of possible productions for that non-terminal. This design allows multiple productions for a single non-terminal to be stored efficiently. The `startSymbol` string identifies the starting symbol of the grammar, which is the symbol from which all valid strings in the language begin their derivation.

### Constructor and Validation

The constructor initializes the grammar with deep copies of the input collections to ensure immutability:

```java
public Grammar(Set<String> nonTerminals, Set<String> terminals, 
               Map<String, Set<String>> productionRules, String startSymbol) {
    this.nonTerminals = new HashSet<>(nonTerminals);
    this.terminals = new HashSet<>(terminals);
    this.productionRules = new HashMap<>();

    // Deep copy of the production rules
    for (Map.Entry<String, Set<String>> entry : productionRules.entrySet()) {
        this.productionRules.put(entry.getKey(), new HashSet<>(entry.getValue()));
    }

    // Verify start symbol is a non-terminal
    if (!nonTerminals.contains(startSymbol)) {
        throw new IllegalArgumentException("Start symbol must be a non-terminal");
    }
    this.startSymbol = startSymbol;

    validateGrammar();
}
```

This constructor performs several important operations. First, it creates new HashSet objects for the non-terminals and terminals to prevent the original collections from being modified. Next, it creates a deep copy of the production rules by iterating through each entry in the input map and creating a new HashSet for each set of productions. This comprehensive copying ensures that any changes to the original collections won't affect the Grammar instance.

The constructor also verifies that the start symbol exists in the set of non-terminals, throwing an IllegalArgumentException if this constraint is violated. Finally, it calls the `validateGrammar()` method, which checks additional constraints to ensure the grammar is well-formed, such as verifying that all symbols used in productions are defined as either terminals or non-terminals.

### Grammar Transformations

#### 1. Removing Null Productions

The `removeNullProductions()` method eliminates empty productions (ε-productions) from the grammar while preserving the language generated:

```java
public Grammar removeNullProductions() {
    // Step 1: Find all nullable non-terminals
    Set<String> nullableNonTerminals = findNullableNonTerminals();

    // Step 2 & 3: Add new productions by omitting nullable non-terminals
    Map<String, Set<String>> newProductionRules = new HashMap<>();

    for (Map.Entry<String, Set<String>> entry : productionRules.entrySet()) {
        String lhs = entry.getKey();
        Set<String> newProductions = new HashSet<>();

        for (String production : entry.getValue()) {
            if (production.equals("ε")) continue; // Skip the empty production for now

            // Generate all possible new productions by omitting nullable non-terminals
            List<String> symbols = Arrays.asList(production.split(" "));
            List<String> generatedProductions = generateAllPossibleProductions(symbols, nullableNonTerminals);

            newProductions.addAll(generatedProductions);
        }

        // If the original rule had an empty production and we didn't add any empty production
        // from the generation process, we need to keep the original empty production
        if (entry.getValue().contains("ε") && !nullableNonTerminals.contains(lhs)) {
            newProductions.add("ε");
        }

        newProductionRules.put(lhs, newProductions);
    }

    // Step 4: Remove all direct null productions unless the start symbol can derive empty
    for (Map.Entry<String, Set<String>> entry : newProductionRules.entrySet()) {
        entry.getValue().removeIf(production -> production.equals("ε"));
    }

    return new Grammar(nonTerminals, terminals, newProductionRules, startSymbol);
}
```

This method implements a complex algorithm to eliminate null productions while preserving the language generated. The process involves several steps:

First, it identifies all "nullable" non-terminals—those that can derive the empty string ε—using the helper method `findNullableNonTerminals()`. This is a crucial step because these symbols can be optionally omitted in productions.

Next, it iterates through all production rules and, for each production that isn't directly ε, it generates all possible variations by optionally omitting nullable symbols. For example, if A → BCD and both B and D are nullable, it would generate A → BCD, A → BC, A → CD, and A → C. This is done using the `generateAllPossibleProductions()` helper method, which systematically creates all combinations.

The method also handles the special case where a rule originally had a direct ε-production. It ensures that this empty production is kept only if necessary for language preservation.

Finally, it removes all direct null productions from the new grammar, as they are no longer needed (their effect has been captured in the generated variations). The method returns a new Grammar instance with the modified production rules, maintaining the immutability of the original grammar.

#### 2. Removing Inaccessible Symbols

The `removeInaccessibleSymbols()` method removes symbols that cannot be reached from the start symbol through any derivation:

```java
private Set<String> findAccessibleSymbols() {
    Set<String> accessibleSymbols = new HashSet<>();
    Set<String> accessibleNonTerminals = new HashSet<>();

    // Start with the start symbol
    accessibleSymbols.add(startSymbol);
    accessibleNonTerminals.add(startSymbol);

    boolean changed;
    do {
        changed = false;
        Set<String> newAccessibleSymbols = new HashSet<>();

        // For each accessible non-terminal
        for (String nonTerminal : accessibleNonTerminals) {
            Set<String> productions = productionRules.getOrDefault(nonTerminal, new HashSet<>());

            // For each production rule
            for (String production : productions) {
                if (production.equals("ε")) continue;

                // For each symbol in the production
                String[] symbols = production.split(" ");
                for (String symbol : symbols) {
                    if (!accessibleSymbols.contains(symbol)) {
                        newAccessibleSymbols.add(symbol);
                        changed = true;

                        // If the symbol is a non-terminal, add it to accessible non-terminals
                        if (nonTerminals.contains(symbol)) {
                            accessibleNonTerminals.add(symbol);
                        }
                    }
                }
            }
        }

        // Add all newly found accessible symbols
        accessibleSymbols.addAll(newAccessibleSymbols);

    } while (changed);

    return accessibleSymbols;
}
```

The `findAccessibleSymbols()` method implements a breadth-first search to discover all symbols reachable from the start symbol. The algorithm works iteratively:

It begins by marking the start symbol as accessible and placing it in both `accessibleSymbols` and `accessibleNonTerminals` sets. The former tracks all accessible symbols (both terminals and non-terminals), while the latter focuses only on non-terminals to optimize the search.

The algorithm then enters a loop that continues until no new symbols are discovered. In each iteration, it examines all known accessible non-terminals and their productions. For each production, it extracts the individual symbols and checks if they're already known to be accessible. If not, they're added to a temporary set of newly discovered symbols.

When a new non-terminal is discovered, it's added to the `accessibleNonTerminals` set so its productions will be examined in subsequent iterations. The algorithm continues this process until no new symbols are found, indicating that all accessible symbols have been discovered.

#### 3. Removing Unit Productions

The `removeUnitProductions()` method eliminates unit productions (A → B where B is a non-terminal) while preserving the language generated:

```java
public Grammar removeUnitProductions() {
    // Step 1: Compute unit production closures for each non-terminal
    Map<String, Set<String>> unitClosure = new HashMap<>();

    // Initialize each non-terminal's closure with itself
    for (String nonTerminal : nonTerminals) {
        Set<String> closure = new HashSet<>();
        closure.add(nonTerminal);
        unitClosure.put(nonTerminal, closure);
    }

    // Compute the transitive closure of unit productions
    boolean changed;
    do {
        changed = false;
        for (String nonTerminal : nonTerminals) {
            Set<String> closure = unitClosure.get(nonTerminal);
            Set<String> newMembers = new HashSet<>();

            for (String member : closure) {
                Set<String> productions = productionRules.getOrDefault(member, new HashSet<>());
                for (String production : productions) {
                    // Check if the production is a unit production (single non-terminal)
                    if (!production.contains(" ") && nonTerminals.contains(production)) {
                        newMembers.add(production);
                    }
                }
            }

            // Add all new members to the closure
            for (String newMember : newMembers) {
                if (!closure.contains(newMember)) {
                    closure.add(newMember);
                    changed = true;
                }
            }
        }
    } while (changed);

    // Step 2 & 3: Create new production rules by replacing unit productions
    Map<String, Set<String>> newProductionRules = new HashMap<>();

    for (String nonTerminal : nonTerminals) {
        Set<String> newProductions = new HashSet<>();
        Set<String> unitProductions = unitClosure.get(nonTerminal);

        for (String unit : unitProductions) {
            Set<String> productions = productionRules.getOrDefault(unit, new HashSet<>());
            for (String production : productions) {
                // Only add non-unit productions
                if (production.contains(" ") || !nonTerminals.contains(production) || production.equals("ε")) {
                    newProductions.add(production);
                }
            }
        }

        newProductionRules.put(nonTerminal, newProductions);
    }

    return new Grammar(nonTerminals, terminals, newProductionRules, startSymbol);
}
```

This method implements a sophisticated algorithm to eliminate unit productions while preserving the language generated. The process consists of two main phases:

In the first phase, it computes the "unit production closure" for each non-terminal. This is essentially the transitive closure of unit productions—all non-terminals that can be reached through a sequence of unit productions. For example, if A → B, B → C, and C → D are unit productions, then the closure for A would include A, B, C, and D.

The closure computation starts by initializing each non-terminal's closure with itself. Then, in an iterative process, it examines each member of the closure to find more unit productions that can extend the closure. This continues until no new members can be added to any closure, indicating that the transitive closure has been fully computed.

The second phase creates new production rules by replacing unit productions with their non-unit alternatives. For each non-terminal A, it looks at all non-terminals B in its unit closure. For each B, it adds all non-unit productions of B as direct productions of A. This effectively "short-circuits" the unit productions while preserving the language generated.

For example, if A → B is a unit production and B → a | CD are non-unit productions, the algorithm would add A → a | CD to the new grammar, eliminating the need for the unit production A → B.

The result is a grammar that generates the same language but contains no unit productions, which is a key requirement for Chomsky Normal Form.

#### 4. Removing Non-Productive Symbols

The `removeNonProductiveSymbols()` method eliminates symbols that cannot derive any terminal string:

```java
private Set<String> findProductiveNonTerminals() {
    Set<String> productiveNonTerminals = new HashSet<>();
    boolean changed;

    // First, find all non-terminals that directly derive terminal strings
    for (Map.Entry<String, Set<String>> entry : productionRules.entrySet()) {
        String nonTerminal = entry.getKey();
        for (String production : entry.getValue()) {
            if (production.equals("ε")) {
                // Empty string is considered a terminal string
                productiveNonTerminals.add(nonTerminal);
                break;
            }

            String[] symbols = production.split(" ");
            boolean allTerminals = true;

            for (String symbol : symbols) {
                if (nonTerminals.contains(symbol)) {
                    allTerminals = false;
                    break;
                }
            }

            if (allTerminals) {
                productiveNonTerminals.add(nonTerminal);
                break;
            }
        }
    }

    // Then, iteratively find more productive non-terminals
    do {
        changed = false;

        for (Map.Entry<String, Set<String>> entry : productionRules.entrySet()) {
            String nonTerminal = entry.getKey();
            if (productiveNonTerminals.contains(nonTerminal)) continue;

            for (String production : entry.getValue()) {
                if (production.equals("ε")) {
                    productiveNonTerminals.add(nonTerminal);
                    changed = true;
                    break;
                }

                String[] symbols = production.split(" ");
                boolean allProductive = true;

                for (String symbol : symbols) {
                    if (nonTerminals.contains(symbol) && !productiveNonTerminals.contains(symbol)) {
                        allProductive = false;
                        break;
                    }
                }

                if (allProductive) {
                    productiveNonTerminals.add(nonTerminal);
                    changed = true;
                    break;
                }
            }
        }
    } while (changed);

    return productiveNonTerminals;
}
```

The `findProductiveNonTerminals()` method implements a bottom-up algorithm to identify all non-terminals that can derive terminal strings (i.e., are "productive"):

The algorithm works in two phases. In the first phase, it identifies all "directly productive" non-terminals—those that have at least one production consisting entirely of terminal symbols or the empty string ε. These non-terminals can immediately derive terminal strings without requiring any substitutions.

In the second phase, it iteratively expands the set of productive non-terminals by examining each non-terminal not yet in the productive set. If a non-terminal has a production where all symbols are either terminals or already identified as productive, then this non-terminal is also productive and is added to the set.

The algorithm continues this iterative process until no new productive non-terminals are found, indicating that the set of productive non-terminals is complete. Any non-terminals not in this set cannot derive any terminal string, either directly or indirectly, and are therefore non-productive.

#### 5. Converting to Chomsky Normal Form

The `toChomskyNormalForm()` method transforms the grammar to have productions of only these forms: A → BC (where B and C are non-terminals) or A → a (where a is a terminal):

```java
public Grammar toChomskyNormalForm() {
    // Create copies to modify
    Set<String> newNonTerminals = new HashSet<>(nonTerminals);
    Set<String> newTerminals = new HashSet<>(terminals);
    Map<String, Set<String>> newProductionRules = new HashMap<>();
    
    // Deep copy of the production rules
    for (Map.Entry<String, Set<String>> entry : productionRules.entrySet()) {
        newProductionRules.put(entry.getKey(), new HashSet<>(entry.getValue()));
    }

    // Step 1: Replace terminals in mixed productions
    int terminalNonTerminalCounter = 1;
    Map<String, String> terminalToNonTerminal = new HashMap<>();

    // First pass: create new non-terminals for terminals
    for (String terminal : terminals) {
        String newNonTerminal = "X" + terminalNonTerminalCounter++;
        terminalToNonTerminal.put(terminal, newNonTerminal);

        // Add a new production rule X -> terminal
        Set<String> newProduction = new HashSet<>();
        newProduction.add(terminal);
        newProductionRules.put(newNonTerminal, newProduction);
        newNonTerminals.add(newNonTerminal);
    }

    // Second pass: replace terminals in mixed productions
    Map<String, Set<String>> updatedRules = new HashMap<>();
    
    for (Map.Entry<String, Set<String>> entry : newProductionRules.entrySet()) {
        String lhs = entry.getKey();
        Set<String> productions = entry.getValue();
        Set<String> modifiedProductions = new HashSet<>();
        
        for (String production : productions) {
            // Skip if this is a production X -> terminal (added earlier)
            if (!production.contains(" ") && terminals.contains(production)) {
                modifiedProductions.add(production);
                continue;
            }
            
            String[] symbols = production.split(" ");
            StringBuilder modifiedProduction = new StringBuilder();
            boolean modified = false;
            
            // Check if we need to replace any terminal in a mixed production
            for (int i = 0; i < symbols.length; i++) {
                String symbol = symbols[i];
                
                // If this is a terminal in a production with multiple symbols
                if (terminals.contains(symbol) && symbols.length > 1) {
                    modifiedProduction.append(terminalToNonTerminal.get(symbol));
                    modified = true;
                } else {
                    modifiedProduction.append(symbol);
                }
                
                if (i < symbols.length - 1) {
                    modifiedProduction.append(" ");
                }
            }
            
            if (modified) {
                modifiedProductions.add(modifiedProduction.toString());
            } else {
                modifiedProductions.add(production);
            }
        }
        
        updatedRules.put(lhs, modifiedProductions);
    }
    
    newProductionRules = updatedRules;

    // Step 2: Break longer productions into binary productions
    // Map to store production patterns to their corresponding non-terminal
    Map<String, String> productionPatternMap = new HashMap<>();
    int longProductionCounter = 1;
    boolean madeChanges;

    do {
        madeChanges = false;
        updatedRules = new HashMap<>();

        // Process each non-terminal and its productions
        for (Map.Entry<String, Set<String>> entry : newProductionRules.entrySet()) {
            String lhs = entry.getKey();
            Set<String> productions = entry.getValue();
            Set<String> newProductions = new HashSet<>();

            for (String production : productions) {
                String[] symbols = production.split(" ");

                // If the production has 2 or fewer symbols, keep it as is
                if (symbols.length <= 2) {
                    newProductions.add(production);
                    continue;
                }

                madeChanges = true;

                // Handle productions with more than 2 symbols
                // We'll convert A -> B1 B2 B3...Bn to A -> B1 Y and Y -> B2 B3...Bn
                String firstSymbol = symbols[0];

                // Create the remainder string (B2 B3...Bn)
                StringBuilder remainderBuilder = new StringBuilder();
                for (int i = 1; i < symbols.length; i++) {
                    remainderBuilder.append(symbols[i]);
                    if (i < symbols.length - 1) {
                        remainderBuilder.append(" ");
                    }
                }
                String remainder = remainderBuilder.toString();

                // Check if we already have a non-terminal for this pattern
                String newNonTerminal;
                if (productionPatternMap.containsKey(remainder)) {
                    newNonTerminal = productionPatternMap.get(remainder);
                } else {
                    newNonTerminal = "Y" + longProductionCounter++;
                    productionPatternMap.put(remainder, newNonTerminal);
                    newNonTerminals.add(newNonTerminal);

                    // Create a production rule for the new non-terminal
                    if (!updatedRules.containsKey(newNonTerminal)) {
                        updatedRules.put(newNonTerminal, new HashSet<>());
                    }
                    updatedRules.get(newNonTerminal).add(remainder);
                }

                // Add the new binary production: A -> B1 Y
                newProductions.add(firstSymbol + " " + newNonTerminal);
            }

            updatedRules.put(lhs, newProductions);
        }

        // Update the production rules for the next iteration
        newProductionRules = new HashMap<>();
        for (Map.Entry<String, Set<String>> entry : updatedRules.entrySet()) {
            newProductionRules.put(entry.getKey(), new HashSet<>(entry.getValue()));
        }

    } while (madeChanges);

    return new Grammar(newNonTerminals, newTerminals, newProductionRules, startSymbol);
}
```

The `toChomskyNormalForm()` method implements the final transformation to achieve Chomsky Normal Form. This process involves two main steps:

The first step handles terminals in mixed productions (productions with both terminals and non-terminals or multiple symbols). For each terminal, it creates a new non-terminal (prefixed with "X") and adds a production rule X → terminal. Then, in productions with multiple symbols, it replaces each terminal with its corresponding non-terminal. For example, A → aBC would become A → X₁BC, where X₁ → a. This transformation ensures that terminals only appear in productions of the form A → a.

The second step breaks down longer productions (those with more than two symbols on the right-hand side) into binary productions. This is done iteratively, starting from the left. For example, A → BCD would first be transformed to A → BY₁, Y₁ → CD. If CD is still not binary, another iteration would transform it to Y₁ → CY₂, Y₂ → D. The algorithm uses a map to track production patterns that have already been processed to avoid creating redundant non-terminals.

The algorithm continues this process until all productions conform to CNF—either A → BC (two non-terminals) or A → a (one terminal). The result is a grammar that generates the same language but is in the standardized form required for algorithms like CYK parsing.
### Helper Methods

The class includes a number of helper methods to support these transformations. One particularly important helper is `generateAllPossibleProductions()`, which creates all possible variations of a production by optionally removing nullable symbols:

```java
private void generateProductionsHelper(List<String> symbols, Set<String> nullableNonTerminals,
                                       int index, List<String> current, List<String> result) {
    if (index == symbols.size()) {
        // Avoid adding empty production here, handled separately
        if (!current.isEmpty()) {
            result.add(String.join(" ", current));
        } else {
            // Add "ε" for empty production instead of empty string
            result.add("ε");
        }
        return;
    }

    String symbol = symbols.get(index);

    // Include the current symbol
    current.add(symbol);
    generateProductionsHelper(symbols, nullableNonTerminals, index + 1, current, result);
    current.remove(current.size() - 1);

    // Exclude the current symbol if it's nullable
    if (nullableNonTerminals.contains(symbol)) {
        generateProductionsHelper(symbols, nullableNonTerminals, index + 1, current, result);
    }
}
```

The `generateProductionsHelper()` method is a recursive helper that systematically generates all possible variations of a production by optionally excluding nullable symbols. The algorithm works through a backtracking approach:

The base case occurs when all symbols in the original production have been processed (index equals the size of the symbols list). At this point, it adds the constructed production to the result set. If the constructed production is empty, it adds the empty string symbol "ε" instead.

For each symbol in the original production, the method explores two possibilities:
1. Including the symbol in the new production. It adds the symbol to the current list, recursively processes the next symbol, and then removes the symbol (backtracking).
2. Excluding the symbol if it's nullable. It simply recursively processes the next symbol without adding the current one.

### String Representation

The `toString()` method provides a human-readable representation of the grammar:

```java
@Override
public String toString() {
    StringBuilder sb = new StringBuilder();

    sb.append("Start Symbol: ").append(startSymbol).append("\n");
    sb.append("Non-terminals: ").append(nonTerminals).append("\n");
    sb.append("Terminals: ").append(terminals).append("\n");
    sb.append("Production Rules:\n");

    for (Map.Entry<String, Set<String>> entry : productionRules.entrySet()) {
        sb.append(entry.getKey()).append(" -> ");
        boolean first = true;
        for (String production : entry.getValue()) {
            if (!first) {
                sb.append(" | ");
            }
            sb.append(production);
            first = false;
        }
        sb.append("\n");
    }

    return sb.toString();
}
```

The `toString()` method generates a comprehensive textual representation of the grammar that follows standard notation conventions. The output includes:

1. The start symbol, which is the non-terminal from which all valid strings in the language begin their derivation.
2. The set of all non-terminal symbols in the grammar.
3. The set of all terminal symbols (the actual characters of the language).
4. All production rules, formatted as "A → α | β | γ" where A is a non-terminal and α, β, γ are alternative productions.

## Conclusions / Results

### Results

The implementation of the grammar transformations was tested based on my variant. I used the grammar from `Variant 4` to convert it into Chomsky Normal Form (CNF). The original grammar and the resulting CNF grammar are presented below.

The original grammar consists of five non-terminals (S, A, B, C, D), two terminals (a, b), and various production rules:

```
Original Grammar:
Start Symbol: S
Non-terminals: [A, B, S, C, D]
Terminals: [a, b]
Production Rules:
A -> B | b | A S | b B A B
B -> b | b S | a D | ε
S -> A | b A | a B
C -> B a
D -> A A
```

This grammar has several characteristics that need to be addressed during the transformation to CNF. It contains the null production B → ε and unit productions like S → A and A → B. There are mixed productions with both terminals and non-terminals, such as S → b A, as well as productions with more than two symbols on the right-hand side, like A → b B A B. The grammar also contains inaccessible symbols, as C is never used from the start symbol S.

After applying the series of transformations (removing null productions, inaccessible symbols, non-productive symbols, unit productions, and converting to Chomsky Normal Form), the resulting grammar is:

```
Grammar in Chomsky Normal Form:
Start Symbol: S
Non-terminals: [A, B, S, D, Y1, X1, Y2, X2, Y3, Y4]
Terminals: [a, b]
Production Rules:
A -> a | b | X2 S | X2 Y4 | X2 Y3 | X2 Y2 | X2 Y1 | X2 A | X1 B | X2 B | A S | X1 D
B -> a | b | X2 S | X1 D
S -> a | b | X2 S | X2 Y4 | X2 Y3 | X2 Y2 | X2 Y1 | X2 A | X1 B | X2 B | A S | X1 D
D -> a | b | A A | X2 S | X2 Y4 | X2 Y3 | X2 Y2 | X2 Y1 | X2 A | X1 B | X2 B | A S | X1 D
Y1 -> B Y4
Y2 -> B B
X1 -> a
Y3 -> B A
X2 -> b
Y4 -> A B
```

Several notable changes occurred during this transformation. The non-terminal C has been removed as it was inaccessible from the start symbol. New non-terminals were introduced to standardize the grammar structure. X1 and X2 replace terminals in mixed productions (X1 → a, X2 → b), while Y1, Y2, Y3, and Y4 were created to break down longer productions into binary form.

The null production B → ε has been eliminated from the grammar. This removal cascaded into generating new productions for rules that contained B, accounting for its potential absence. This is why we see more production alternatives in the transformed grammar.

All unit productions have been eliminated and replaced with their corresponding non-unit alternatives. This process often expands the grammar significantly, as each unit production chain must be replaced with direct derivations to non-unit productions.

The resulting grammar now conforms to CNF requirements. Each production is either of form A → BC where B and C are non-terminals (like Y3 → B A), or of form A → a where a is a terminal (like X1 → a). This standardization is important for many parsing algorithms, such as the CYK algorithm, which require grammars to be in this specific form.


### Conclusions

In this laboratory work, I successfully implemented a solution for converting context-free grammars to Chomsky Normal Form. The implementation follows a systematic approach that preserves the language while transforming the grammar structure.

Through the process of removing null productions, unit productions, inaccessible symbols, and non-productive symbols, followed by converting productions to the appropriate form, I gained practical experience with formal language theory concepts. The implementation demonstrated how each transformation step affects the grammar while maintaining its generative power.

The test results showed a significant increase in grammar size—from 5 to 10 non-terminals—which is a typical outcome when converting to CNF. This trade-off between structural complexity and standardization is necessary for compatibility with algorithms like CYK parsing.

The immutable design of the Grammar class allowed for easy tracking of transformations, while the ordered application of transformation steps ensured correctness. Handling edge cases such as nullable symbols in multiple positions within productions proved the robustness of the implementation.

This laboratory work reinforced the distinction between a grammar's structure and the language it generates, demonstrating that different syntactic forms can produce the same language. The implementation provides a practical foundation for understanding grammar normalization and its applications in language processing.

## References
****
<a id="ref1"></a>[1] Laboratory Work 1: Intro to formal languages. Regular grammars. Finite Automata. task.md - Crețu Dumitru, Drumea Vasile, Cojuhari Irina -
https://github.com/filpatterson/DSL_laboratory_works/blob/master/1_RegularGrammars/task.md

<a id="ref2"></a>[2] "Formal Languages and Finite Automata guide for practical lessons" - COJUHARI Irina, DUCA Ludmila, FIODOROV Ion -
https://else.fcim.utm.md/pluginfile.php/110458/mod_resource/content/0/LFPC_Guide.pdf

<a id="ref3"></a>[3] Presentation on "Formal Languages and Compiler Design" - conf. univ., dr. Irina Cojuhari -
https://else.fcim.utm.md/pluginfile.php/110457/mod_resource/content/0/Theme_1.pdf

<a id="ref4"></a>[4] Presentation on "Regular Language. Finite Automata" - TUM -
https://drive.google.com/file/d/1rBGyzDN5eWMXTNeUxLxmKsf7tyhHt9Jk/view



